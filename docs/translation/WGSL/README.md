## 前言

此翻译版本是[凡生](https://github.com/d1zzzzy)根据[WebGPU Shading Language](https://gpuweb.github.io/gpuweb/wgsl)的个人翻译版本，仅供学习交流使用，不得用于商业用途。


## 本文档的更多细节

### 当前版本

[地址](https://github.com/gpuweb/gpuweb/blob/e1ded4a401dbfacfe40dea46f77f81dbbbc7a382/wgsl/index.bs)

### 最近发布的版本

[https://www.w3.org/TR/WGSL/](https://www.w3.org/TR/WGSL/)

### 反馈

[Github](https://github.com/gpuweb/gpuweb/issues/)

## 摘要

Shading language for WebGPU。

## 文档状态

这份规范由[Web社区组织的GPU小组](https://www.w3.org/community/gpu/)发布。它不是W3C标准，也不在W3C标准轨道上。请注意，根据[W3C社区贡献者许可协议（CLA）]
(https://www.w3.org/community/about/agreements/cla/)，有限的选择退出和其他条件适用。了解更多关于[W3C社区和商业团体](http://www.w3.org/community/)的信息。

## 目录

### 1 介绍

#### 1.1 概述

在 WebGPU 中，向 GPU 发送工作单元是通过 GPU 命令的形式实现的。WGSL（WebGPU Shading Language）主要关注两种类型的 GPU 命令：

1. **绘制命令（Draw Command）**：这种命令执行渲染管线（render pipeline），在给定的输入、输出和附加资源的上下文中进行。渲染管线主要用于处理图形渲染任务，如绘制三维场景、处理纹理和颜色等。在这种情况下，WGSL 着色器可能包括顶点着色器、片段着色器等，用于处理图形渲染的各个阶段。

2. **分发命令（Dispatch Command）**：这种命令执行计算管线（compute 
   pipeline），在给定的输入和附加资源的上下文中进行。计算管线专注于执行一般的计算任务，而不是直接处理图形渲染。这些任务可能包括数据并行处理、物理模拟等。在这种情况下，WGSL 着色器是计算着色器，专门用于处理这些类型的计算任务。

在这两种类型的管线中，WGSL 着色器起着至关重要的作用。着色器是小型程序，用于在 GPU 上执行特定的图形或计算操作。通过使用 WGSL 编写的着色器，WebGPU 能够充分利用 GPU 的高并行处理能力来执行复杂的渲染和计算任务。这使得 WGSL 成为开发高效、现代网页图形和计算应用的重要工具。

在 WGSL 程序中，着色器是执行管线中一个着色器阶段的部分。一个着色器包括以下几个部分：

1. **入口点函数**：这是着色器的起始点，管线执行时从这里开始执行着色器代码。

2. **所有被调用函数的传递闭包**：从入口点开始，这个集合包括了所有被调用的函数，无论是用户定义的还是内置的函数。这里提到的“传递闭包”是一个更严格的定义，它包括了所有从入口点函数直接或间接调用的函数。

3. **所有这些函数静态访问的变量和常量集合**：这包括了在着色器中使用的所有变量和常量，它们是着色器执行所需的数据。

4. **用于定义或分析所有这些函数、变量和常量的类型集合**：这涉及到着色器中使用的各种数据类型，包括基本类型、结构体、数组等。

> Note: 入口点不是强制性的：在 WGSL 程序中，虽然不强制要求一定要有入口点函数，但是没有入口点的程序无法执行：尽管可以编写不含入口点的 WGSL 程序，但如果没有定义入口点，这样的程序是无法被 WebGPU API 
> 执行的。这是因为创建 GPUProgrammableStage（GPU 可编程阶段）时需要一个入口点。

执行着色器阶段时，会经过下面的步骤：

1. **计算在模块作用域中声明的常量的值**。

2. **将资源绑定到着色器资源接口中的变量**，使得这些资源的内容在执行期间对着色器可用。

3. **为其他模块作用域变量分配内存**，并用指定的初始值填充这些内存。

4. **如果存在，用着色器阶段的输入填充入口点的形式参数**。

5. **如果存在，将入口点的返回值连接到着色器阶段的输出**。

然后，它调用入口点。

一个 WGSL（WebGPU Shading Language）程序包括：

1. **指令（Directives）**：指定模块级别的行为控制。

2. **函数（Functions）**：指定执行行为。

3. **语句（Statements）**：是声明或可执行行为的单元。

4. **字面量（Literals）**：是纯数学值的文本表示。

5. **常量（Constants）**：为在特定时间计算出的值提供名称。

6. **变量（Variables）**：为存储值的内存提供名称。

7. **表达式（Expressions）**：结合一组值产生结果值。

8. **类型（Types）**：每种类型描述：
	- 一组值。
	- 对支持的表达式的约束。
	- 这些表达式的语义。

9. **属性（Attributes）**：修改对象以指定额外信息，如：
	- 指定入口点的接口。
	- 指定诊断过滤器。

> Note: 当前，一个 WGSL（WebGPU Shading Language）程序由单个 WGSL 模块组成。

WGSL（WebGPU Shading Language）是一种命令式语言：行为被指定为一系列要执行的语句。语句可以：

1. **声明常量或变量**。

2. **修改变量的内容**。

3. **使用结构化编程构造来修改执行顺序**：
	- 选择性执行：if（可选的 else if 和 else 子句）、switch。
	- 循环：loop、while、for。
	- 逃离嵌套执行结构：continue、break、break if。
	- 重构：函数调用和返回。

4. **求值表达式以计算上述行为的一部分的值**。

5. **在着色器创建时检查关于常量表达式的假设**。

WGSL（WebGPU Shading Language）是静态类型的：特定表达式计算出的每个值都有一个特定的类型，这个类型仅通过检查程序源码来确定。

WGSL 拥有描述布尔值和数字（整数和浮点数）的类型。这些类型可以聚合成复合类型（向量、矩阵、数组和结构体）。WGSL 有一些特殊类型（例如原子类型），提供独特的操作。WGSL 描述了可以作为内存视图存储在内存中的类型。WGSL 提供了通常用于渲染的类型，如纹理和采样器。这些类型有关联的内置函数，用以暴露通常由 GPU 硬件提供的图形渲染功能。

WGSL 没有从具体类型到其他类型的隐式转换或提升，但确实提供了从抽象类型到其他类型的隐式转换和提升。将一个值从一个具体的数字或布尔类型转换为另一个类型需要明确的转换、值构造器，或位的重新解释；然而，WGSL 提供了有限的功能来将标量类型提升为向量类型。这也适用于复合类型。

着色器阶段的工作被划分为一个或多个调用，每个调用都执行入口点，但在略微不同的条件下进行。同一着色器阶段中的调用共享对某些变量的访问：

1. **阶段中所有调用共享着色器接口中的资源**。

2. **在计算着色器中，同一工作组中的调用共享工作组地址空间中的变量**。不同工作组中的调用不共享这些变量。

然而，这些调用对不同的着色器阶段输入集合进行操作，包括提供用于区分调用与其同伴的标识值的内置输入。每个调用都有自己独立的内存空间，以私有和函数地址空间中的变量的形式存在。

在一个着色器阶段内的调用是并发执行的，而且通常会并行执行。着色器的编写者负责确保着色器阶段中调用的动态行为：

1. **满足某些原始操作的一致性要求**，包括纹理采样和控制障碍。

2. **协调对共享变量的潜在冲突访问**，以避免数据竞争。

WGSL（WebGPU Shading Language）有时允许给定特性有几种可能的行为。这是一个可移植性风险，因为不同的实现可能会展示不同的行为。WGSL 的设计旨在最小化这类情况，但受到可行性的限制，以及在广泛的设备上实现高性能的目标的制约。

行为要求是实现在处理或执行 WGSL 程序时将执行的动作。它们描述了实现在与程序员的合同中的义务。当这些义务可能不是显而易见的时，规范会明确地陈述它们。

#### 1.2 语法表示法

WGSL（WebGPU Shading Language）的语法语义的约定描述如下：

+ 斜体文本：规则的两侧使用斜体文本表示一个语法规则。
+ 加粗等宽文本：规则右侧用单引号（'）开始和结束的加粗等宽文本表示关键词和令牌。
+ 冒号（:）：在常规文本中，冒号注册一个语法规则。
+ 竖线（|）：在常规文本中，竖线表示选择性的替代。
+ 问号（?）：在常规文本中，问号表示前面的关键词、令牌、规则或组出现零次或一次（是可选的）。
+ 星号（*）：在常规文本中，星号表示前面的关键词、令牌、规则或组出现零次或多次。
+ 加号（+）：在常规文本中，加号表示前面的关键词、令牌、规则或组出现一次或多次。
+ 一对匹配的括号（()）：在常规文本中，一对开放的括号（()）和关闭的括号（()）表示一个元素组。

#### 1.3 数学术语和符号

**角度**

+ 按照惯例，角度以弧度为单位测量。
+ 测量角度的参考射线是从原点（0,0）指向（+∞,0）的射线。
+ 让 θ 代表比较射线和参考射线所夹的角度。当比较射线逆时针移动时，θ 增加。
+ 完整圆中有 2π 弧度。
+ 示例：
  - 角度 0 从原点指向右侧，朝向（1,0）。
  - 角度 2π 从原点指向右侧，朝向（1,0）。
  - 角度 π/4 从原点指向点（1,1）。
  - 角度 π/2 从原点指向点（0,1）。
  - 角度 π 从原点指向点（-1,0）。
  - 角度 (3/2)π 从原点指向点（0,-1）。

**双曲角**是一个无单位的面积，而不是传统意义上的角度。
  - 考虑双曲线 `x^2 - y^2 = 1`，对于 `x > 0`。
  - 让 R 是一条从原点到双曲线上某点 (x, y) 的射线。
  - 让 a 是 R、x 轴和双曲线曲线本身所围成的两倍面积。
  - 当 R 在 x 轴上方时，考虑 a 为正；在下方时，为负。

那么面积 a 就是一个双曲角，其中 x 是 a 的双曲余弦，y 是 a 的双曲正弦：

该**区间**是一组具有下限和上限的连续数字。 根据上下文，它们是整数、浮点数或实数的集合。

+ 闭区间 `[a,b]` 是一组满足 `a ≤ x ≤ b` 的数字集合。
+ 半开区间 `[a,b)` 是一组满足 `a ≤ x < b` 的数字集合。
+ 半开区间 `(a,b]` 是一组满足 `a < x ≤ b` 的数字集合。

**地板表达式**

对于实数 x（包括 +∞ 和 −∞），`⌊x⌋ = k`，其中 k 是唯一的整数使得 `k ≤ x < k+1`。

**天花板表达式**

对于实数 x（包括 +∞ 和 −∞），`⌈x⌉ = k`，其中 k 是唯一的整数使得 `k-1 < x ≤ k`。

**截断函数**

对于实数 x（包括 +∞ 和 −∞），计算最接近 x 的整数，其绝对值小于或等于 x 的绝对值：如果 x ≥ 0，则 `truncate(x) = ⌊x⌋`；如果 x < 0，则 `truncate(x) = ⌈x⌉`。

**向上取整函数**

对于正整数 k 和 n，`roundUp(k, n) = ⌈n ÷ k⌉ × k`。

**矩阵转置**

`c` 列 `r` 行矩阵 `A` 的转置是 `r` 列 `c` 行矩阵 `AT`，通过将 `A` 的行作为 `AT` 的列来复制形成：`transpose(A) = AT`，`transpose(A)i`,`j = Aj`,`i`。
列向量的转置通过将列向量解释为 1 行矩阵来定义。同样，行向量的转置通过将行向量解释为 1 列矩阵来定义。

### 2 WGSL模块

#### 2.1 着色器的声明周期

#### 2.2 错误

#### 2.3 诊断

##### 2.3.1 诊断处理

##### 2.3.2 可过滤的触发规则

##### 2.3.3 诊断过滤

#### 2.4 限制

### 3 文本结构

#### 3.1 解析

#### 3.2 空格与换行

#### 3.3 注释

#### 3.4 Tokens

#### 3.5 字面量

##### 3.5.1 布尔字面量

##### 3.5.2 数字字面量

#### 3.6 关键字

#### 3.7 标识符

##### 3.7.1 标识符比较

#### 3.8 上下文依赖的名称

#### 3.9 诊断规则名称

#### 3.10 模板列表

### 4 指令

#### 4.1 扩展

##### 4.1.1 开启扩展

##### 4.1.2 语言扩展

#### 4.2 全局诊断过滤

### 5 声明与范围
### 6 类型
### 7 变量与值声明
### 8 表达式
### 9 语句
### 10 函数
### 11 属性
### 12 入口
### 13 内存
### 14 执行
### 15 关键字与Token的总览
### 16 内置函数
### 17 递归下降语法分析
